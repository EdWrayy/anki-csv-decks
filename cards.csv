Main method signature,"int main (void)
{
return 0;
{"
How to print a value?,"printf(""Value: %i"",number);

%i is a placeholder for the int
%c is char
%f is float
ect."
Why do we need to be careful with arrays in C?,C does not check for array bounds
How does variable declaration and initialization work?,"When we declare a variable it gets allocated some memory space at an address. It's value is not initialized a default, it gets whatever value is at that address until we initialize it."
How do we declare a pointer?,"Specify a type and prefix an * to the variable name.
E.g: int *intPointer;"
How do we get the address of a pointer?,"Using the & operator.
E.g: printf(""intPoitner is located at %p\n"",&intPointer);
E.g: intPointer = &otherInt; (assigns the value of otherInt to intPoitner)"
Assigning pointers to an array,"An array is just a memory address of multiple variables, so when assigning the pointer to it we do not need to use the & notation.
E.g:
int *arrayPointer;
int array[5] = {2,4,6,8,10};
arrayPointer = array;

If we do arrayPointer = &array then we assign the memory address of the entire array not just the first element."
How do we extract the value of a pointer? (for changing and reading),"Using the * sign.
E.g:
int exampleInt;
int *pointer;
pointer = &exampleInt;
*pointer = 50; (assigns 50 to the value of the memory address).
In a way, *pointer and exampleInt become the same thing.


REMEBER: The pointer must have an address initialized to be able to assign it a value."
How to iterate through an array using a pointer,"int array[5];
int *arrayPointer;
int x;
arrayPointer = array;

for(x=0; x<5; x++)
{
array[x] = x;
printf(""array[%i] at %p = %i\n"",x,arrayPointer,array[x])
arrayPointer++;
}

We just need to use pointer++, the compiler knows how far to move along the memory address."
What does this tell the compiler? *c++,"Tells the compiler to apply ++ to c, then extract the memory address.
This is important because ++ is more binding than *."
What does malloc do,"Takes one argument which specifies the number of bytes to be reserved, returning a pointer to the beginning of the allocated storage area in the memory.

E.g:
int *p;
p = malloc(n * sizeof(int));

This is a good way of initializing a pointer without using other variables. It is good practice to use the sizeof() function rather than what we assume the size is, will help for complex structures.

It is possible that it cannot allocated the requested memoery and might return NULL (special pointer reserved to indicated the pointer does not point to anything).

Malloc does not set the values of the address to anything, so we do not know what the default values are."
What does the free function do,"Takes a pointer and returns its memory to the heap when we are done with it.
E.g:
int *p;
p = malloc(10*sizeof(int));
//Do what we need with p
free(p);"
How does calloc differ from malloc,"Takes two arguments, the number of elements to be reserved and the size of each element in bytes. This is particularly useful for creating arrays. 
The value of the memory addresses are also automatically set to 0.

E.g:
int *p;
p = calloc(10, sizeof(int));

//We can then iterate through this like an array.
for(int x = 0; x<10; x++)
{
printf(""%i lives at %p\n"",*(p+x),p+x);
}
free(p);"
What does realloc do?,"Changes the size of previously allocated memory (using malloc or calloc) and returns a pointer to the new memory block.

E.g:
int *p;
p = malloc(10*sizeof(int));
p = realloc(p, 20*sizeof(int));"
Functions,"<span style=""background-color: rgb(54, 54, 54); color: rgb(255, 255, 255);"">returnType functionName(parameterType parameterName, parameterType2, parameterName2){...}<br style=""box-sizing: inherit; color: rgb(246, 247, 251); background-color: rgb(46, 56, 86);""><br style=""box-sizing: inherit; color: rgb(246, 247, 251); background-color: rgb(46, 56, 86);"">If we have no return type we write void.<br style=""box-sizing: inherit; color: rgb(246, 247, 251); background-color: rgb(46, 56, 86);"">Similarly if we have no parameters we must write void as well.<br style=""box-sizing: inherit; color: rgb(246, 247, 251); background-color: rgb(46, 56, 86);""><br style=""box-sizing: inherit; color: rgb(246, 247, 251); background-color: rgb(46, 56, 86);"">E.g:<br style=""box-sizing: inherit; color: rgb(246, 247, 251); background-color: rgb(46, 56, 86);"">int calculateTriangularNumber(int n){...}<br style=""box-sizing: inherit; color: rgb(246, 247, 251); background-color: rgb(46, 56, 86);"">int number = 3;<br style=""box-sizing: inherit; color: rgb(246, 247, 251); background-color: rgb(46, 56, 86);"">int output;<br style=""box-sizing: inherit; color: rgb(246, 247, 251); background-color: rgb(46, 56, 86);"">output = calculateTriangularNumber(number);</span>"
Using arrays as parameters in functions,"It is not possible to find the size of an array in C after it is created. 
Therefore we must make a note of this when we create an array, and if we use an array as a parameter in a function which requires its size we must also include its size as a parameter."
How do functions modify the parameters,"In C, when we pass in a variable as a parameter the function receives a copy of the value at a different memory address, and therefore cannot actually modify the original variable.

We can only modify the original variable at its original address if we use a pointer or an array as a parameter."
Why do we have to be careful with the ordering of function declarations.,"<span style=""color: rgb(246, 247, 251); background-color: rgb(54, 54, 54);"">In C, when we call a function from the main routine, the compiler automatically expects the function to return an int. However if we define the function before the main routine, then the compiler will know the return value before it is called. Therefore it is good practice to always declare functions before they are called.</span>"
Structures,"<span style=""background-color: rgb(54, 54, 54);""><span style=""color: rgb(246, 247, 251);"">We can define our own datatypes as a combination of other primitive data types, a bit like classes which we can create objects of.</span><br style=""box-sizing: inherit; color: rgb(246, 247, 251); background-color: rgb(46, 56, 86);""><br style=""box-sizing: inherit; color: rgb(246, 247, 251); background-color: rgb(46, 56, 86);""><span style=""color: rgb(246, 247, 251);"">They follow the format:</span><br style=""box-sizing: inherit; color: rgb(246, 247, 251); background-color: rgb(46, 56, 86);""><span style=""color: rgb(246, 247, 251);"">struct structName</span><br style=""box-sizing: inherit; color: rgb(246, 247, 251); background-color: rgb(46, 56, 86);""><span style=""color: rgb(246, 247, 251);"">{</span><br style=""box-sizing: inherit; color: rgb(246, 247, 251); background-color: rgb(46, 56, 86);""><span style=""color: rgb(246, 247, 251);"">member1Type member1Name</span><br style=""box-sizing: inherit; color: rgb(246, 247, 251); background-color: rgb(46, 56, 86);""><span style=""color: rgb(246, 247, 251);"">member2Type member2Name</span><br style=""box-sizing: inherit; color: rgb(246, 247, 251); background-color: rgb(46, 56, 86);""><span style=""color: rgb(246, 247, 251);"">};</span><br style=""box-sizing: inherit; color: rgb(246, 247, 251); background-color: rgb(46, 56, 86);""><br style=""box-sizing: inherit; color: rgb(246, 247, 251); background-color: rgb(46, 56, 86);""><span style=""color: rgb(246, 247, 251);"">We then declare a new variable of this like so:</span><br style=""box-sizing: inherit; color: rgb(246, 247, 251); background-color: rgb(46, 56, 86);""><span style=""color: rgb(246, 247, 251);"">struct structName variableName;</span><br style=""box-sizing: inherit; color: rgb(246, 247, 251); background-color: rgb(46, 56, 86);""><span style=""color: rgb(246, 247, 251);"">variableName.member1Name = x;</span><br style=""box-sizing: inherit; color: rgb(246, 247, 251); background-color: rgb(46, 56, 86);""><span style=""color: rgb(246, 247, 251);"">variableName.member2Name = y;</span><br style=""box-sizing: inherit; color: rgb(246, 247, 251); background-color: rgb(46, 56, 86);""><br style=""box-sizing: inherit; color: rgb(246, 247, 251); background-color: rgb(46, 56, 86);""><span style=""color: rgb(246, 247, 251);"">E.g:</span><br style=""box-sizing: inherit; color: rgb(246, 247, 251); background-color: rgb(46, 56, 86);""><span style=""color: rgb(246, 247, 251);"">struct time</span><br style=""box-sizing: inherit; color: rgb(246, 247, 251); background-color: rgb(46, 56, 86);""><span style=""color: rgb(246, 247, 251);"">{</span><br style=""box-sizing: inherit; color: rgb(246, 247, 251); background-color: rgb(46, 56, 86);""><span style=""color: rgb(246, 247, 251);"">int hour;</span><br style=""box-sizing: inherit; color: rgb(246, 247, 251); background-color: rgb(46, 56, 86);""><span style=""color: rgb(246, 247, 251);"">int min;</span><br style=""box-sizing: inherit; color: rgb(246, 247, 251); background-color: rgb(46, 56, 86);""><span style=""color: rgb(246, 247, 251);"">int sec;</span><br style=""box-sizing: inherit; color: rgb(246, 247, 251); background-color: rgb(46, 56, 86);""><span style=""color: rgb(246, 247, 251);"">}</span><br style=""box-sizing: inherit; color: rgb(246, 247, 251); background-color: rgb(46, 56, 86);""><br style=""box-sizing: inherit; color: rgb(246, 247, 251); background-color: rgb(46, 56, 86);""><span style=""color: rgb(246, 247, 251);"">This can then be used like so:</span><br style=""box-sizing: inherit; color: rgb(246, 247, 251); background-color: rgb(46, 56, 86);""><span style=""color: rgb(246, 247, 251);"">struct time meeting1;</span><br style=""box-sizing: inherit; color: rgb(246, 247, 251); background-color: rgb(46, 56, 86);""><span style=""color: rgb(246, 247, 251);"">meeting1.hour = 14;</span><br style=""box-sizing: inherit; color: rgb(246, 247, 251); background-color: rgb(46, 56, 86);""><span style=""color: rgb(246, 247, 251);"">meeting1.min = 23;</span><br style=""box-sizing: inherit; color: rgb(246, 247, 251); background-color: rgb(46, 56, 86);""><span style=""color: rgb(246, 247, 251);"">meeting1.sec = 38;</span><br style=""box-sizing: inherit; color: rgb(246, 247, 251); background-color: rgb(46, 56, 86);""><br style=""box-sizing: inherit; color: rgb(246, 247, 251); background-color: rgb(46, 56, 86);""><span style=""color: rgb(246, 247, 251);"">OR: struct time meeting1 = {14,23,38};</span></span>"
What does typedef do?,"This allows us to assign an alternate name to an existing data type.

It follows the format: typedef existingDataType newName;
E.g:
typedef int counter;
This means that counter is now equivalent to int"
Left vs Right Associative,"When we have multiple operators with the same precedence, we choose the order based on associativity.
Most operators in C are L -> R associative but there are some R -> L.

Left (also known as L -> R) associative means that we do the left-most operation first, then work towards the right, like reading English naturally.
Right (also known as R -> L) associative means that we do the opposite, right-most first then work towards the left.

We can use brackets to visually demonstrate this order of operations.
For example the expression 3 - 4 - 5 - 10 - 8:

If - is L -> R (which it is in C) then it would be (((3 - 4) - 5) - 10) - 8
If it was R - > L then it would be 3 - (4 - (5 - (10 - 8)))"
Bitwise Operators,"Bitwise operators perform operations directly on the binary representation of numbers at the bit level. 
They are often faster and more efficient than arithmetic operators for specific low-level tasks such as hardware manipulation, encryption, and performance optimizations.
They only work on integers (and chars though less common) in C.

<img src=""bitwise operators C.png"">"
Common Pitfalls with Comparison Operators,"When using comparison operators (==, !=) in C there are a few issues to be aware of:

<b>Floating point precision
</b>Floating-point numbers (float, double) are approximations, not exact values. Direct comparisons can lead to unexpected results.<b>
</b>E.g: Due to floating-point rounding errors, 0.1 + 0.2 is not exactly 0.3.
Solution: Compare using a tolerance value

<b>Mixing Signed and Unsigned Integers
</b>If you compare a signed and an unsigned integer, C may convert the signed integer to unsigned, leading to incorrect results.
E.g: If a = -1 and b = 1 then a < b = false because a is converted to an unsigned int, so -1 becomes 4294967295 (assuming 32-bit unsigned int), which is greater than 1.
Solution: Always cast explicitly or avoid mixing signed and unsigned types - if ((int)b > a)

<b>Other Ocassional Errors
</b>Comparing Pointers not actual values
Undefined Behavior in Integer Overflows
Accidental Assignment (=) Instead of Comparison (==)<b>
</b>"
What is cross compilation?,"Used when we want to run a program on a specific machine, but compiling the program on that machine itself is impossible or impractical.
For example:
First compiler on new hardware or new OS
Low capability targets (embedded systems)

The architecture of the host and target may be vary different:
Memory Architecture (von Neumann / Harvard)
Word size (64 / 8 bit)
Order of bytes in word (endianness)

This means that we need to configure the make file to cross compile correctly."
Make Files and the Build Process in C,"<div>The build process for a C program involves multiple steps:</div>Preprocessing: Expands macros, removes comments, and processes #include directives.
Compilation: Translates .c files into assembly code.
Assembly: Converts assembly code into machine code, generating object files (.o).
Linking: Combines object files into an executable, resolving dependencies and libraries.

A Makefile automates these steps by defining rules and dependencies.
It calls the compiler and manages build configurations."
Memory Sections,"In C programs, memory is divided into distinct sections, each serving a specific purpose. 
These sections are managed by the operating system and the compiler during program execution.

<b>Code (Text) Section</b>
Contains: The compiled machine instructions of the program.
Characteristics: Read-only to prevent accidental modification.
Typically stored in ROM (for embedded systems) or protected memory (for OS-based systems). 
This is typically in the form of flash memory for embedded systems.

<b>rodata</b>
Contains: Constant data, such as string literals (""Hello, world!"") and variables.
Read-only to prevent accidental modification.

<b>data</b>
Initialized global and static variables.
Variables are stored here if they are global or static and have explicit initial values.
Allocated at program startup.

<b>bss</b> (Block Started by Symbol)
Allocated at program startup.
Automatically initialized to zero by the system."
How are memory sections assigned?,"When compiling and executing a C program, the compiler, linker, and loader work together to assign code, data, and memory sections.

The compiler (gcc, clang) compiles .c files into assembly.
The assembler (as) converts the assembly into machine code, producing object files (.o).
Each object file contains different sections, which the linker later organizes.

The linker (ld) takes multiple object files (.o) and libraries, organizing them into a single executable (a.out or ELF binary). 
It assigns sections like .text, .data, .bss, and heap/stack.

It takes into account the scope of the data (program wide, file scope, block scope) and also qualifier's like <b>const</b>"
